{"version":3,"sources":["board.js","card.js","computer_player.js","concentration.js","deck.js","graveyard.js","hud.js","human_player.js","inspector.js","main.js","player.js","turn.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"concentration.all.js","sourcesContent":["function Board($el, graveyard1, graveyard2) {\n  this.$el = $el;\n  this.graveyard1 = graveyard1;\n  this.graveyard2 = graveyard2;\n  this.deck = new Deck().shuffle();\n  this.numCards = this.deck.count();\n}\n\nBoard.prototype.render = function (content) {\n  this.$el.html(content);\n};\n\nBoard.prototype.buildCardTags = function () {\n  return this.deck.cards.map(function (card) {\n    return card.htmlTag();\n  });\n};\n\nBoard.prototype.layCards = function () {\n  var cardTags = this.buildCardTags();\n\n  this.render(cardTags);\n};\n\nBoard.prototype.show = function (cardTag) {\n  cardTag.removeClass('hidden');\n};\n\nBoard.prototype.hide = function (cardTag) {\n  cardTag.addClass('hidden');\n};\n\nBoard.prototype.on = function (evnt, callback) {\n  this.$el.on(evnt, callback);\n};\n\nBoard.prototype.off = function (evnt) {\n  this.$el.off(evnt);\n};\n\nBoard.prototype.remove = function ($cards, player) {\n  var graveyard = (player.id == 1 ? this.graveyard1 : this.graveyard2);\n\n  graveyard.add($cards);\n  this.numCards -= $cards.length;\n  $cards.forEach(function ($cardTags) {\n    $cardTags.addClass('removed');\n  });\n};\n\n","function Card (suit, number) {\n  this.suit = suit;\n  this.number = number;\n}\n\nCard.prototype.span = function () {\n  return $('<span>').append(this.suitSyms(this.suit))\n                    .append(this.numSyms(this.number));\n};\n\nCard.prototype.divTag = function () {\n  var $div = $('<div>');\n  $div.addClass(this.constructor.htmlClass)\n      .addClass('hidden');\n\n  if (this.suit == \"hearts\" || this.suit == \"diamonds\") {\n    $div.addClass('red');\n  }\n\n  $div.data('number', this.number);\n\n  return $div;\n};\n\nCard.prototype.htmlTag = function () {\n  var $span = this.span(),\n      divTag = this.divTag();\n\n  divTag.append($span);\n\n  return divTag[0];\n};\n\nCard.htmlClass = 'card';\n\nCard.prototype.suitSyms = function (suit) {\n  return this.constructor.SUIT_SYMBOLS[suit];\n};\n\nCard.prototype.numSyms = function (num) {\n  return this.constructor.NUMBER_SYMBOLS[num];\n};\n\nCard.SUIT_SYMBOLS = {\n  clubs:    \"&clubs;\",\n  diamonds: \"&diams;\",\n  hearts:   \"&hearts;\",\n  spades:   \"&spades;\"\n};\n\nCard.NUMBER_SYMBOLS = {\n  two:   \"2\",\n  three: \"3\",\n  four:  \"4\",\n  five:  \"5\",\n  six:   \"6\",\n  seven: \"7\",\n  eight: \"8\",\n  nine:  \"9\",\n  ten:   \"10\",\n  jack:  \"J\",\n  queen: \"Q\",\n  king : \"K\",\n  ace  : \"A\"\n};\n\n","function ComputerPlayer ($cards, args) {\n  Player.apply(this, [].slice.call(arguments, 1));\n  this.$cards = $cards;\n}\n\nComputerPlayer.prototype = Object.create(Player.prototype);\nComputerPlayer.prototype.constructor = ComputerPlayer;\n\nComputerPlayer.prototype.getInput = function () {\n  var chose = Q.defer(),\n      $availableCards = this.$cards.filter('.hidden');\n      // Just pick a random, non-hidden card for now\n      chosenCard = $availableCards[Math.floor(Math.random() *\n          $availableCards.length)];\n\n  setTimeout(function () {\n    chose.resolve($(chosenCard));\n  }, this.constructor.THINK_TIME);\n\n  return chose.promise;\n};\n\nComputerPlayer.prototype.confirmNextTurn = function () {\n  var confirmed = Q.defer();\n\n  setTimeout(function () {\n    confirmed.resolve();\n  }, this.constructor.THINK_TIME);\n\n  return confirmed.promise;\n};\n\nComputerPlayer.THINK_TIME = 1000;\n\n","function Concentration () {\n  this.board = null;\n  this.initBoard();\n\n  this.player1 = null;\n  this.player2 = null;\n  this.initPlayers();\n\n  this.turn = new Turn(this.board, this.player1, this.player2);\n  this.hud = null;\n  this.initHud();\n}\n\nConcentration.prototype.initBoard = function () {\n  var $boardEl = $('.board'),\n      $graveyard1El = $('.graveyard#one'),\n      $graveyard2El = $('.graveyard#two'),\n      graveyard1 = new Graveyard($graveyard1El);\n      graveyard2 = new Graveyard($graveyard2El);\n\n  this.board = new Board($boardEl, graveyard1, graveyard2);\n  this.board.layCards();\n};\n\nConcentration.prototype.initPlayers = function () {\n  var $cards = $('.card');\n\n  this.player1 = new HumanPlayer(1, this.board);\n  this.player2 = new ComputerPlayer($cards, 2, this.board);\n  //this.player2 = new HumanPlayer(2, this.board);\n};\n\nConcentration.prototype.initHud = function () {\n  var $hud = $('.hud');\n\n  this.hud = new Hud($hud, this.player1, this.player2);\n  this.hud.render(this.board.numCards);\n};\n\nConcentration.prototype.play = function () {\n  var game = this,\n      gameOver = Q.defer();\n\n  _prompt(this.player1);\n\n  return gameOver.promise;\n\n  function _prompt(currentPlayer) {\n    game.notice('Waiting on: Player ' + currentPlayer.id);\n\n    if (game.endCondition()) return gameOver.resolve();\n\n    game.defer_to(currentPlayer)\n    .then(function (nextOrSamePlayer) {\n      _prompt(nextOrSamePlayer);\n    })\n    .fail(function (err) { throw err; });\n  }\n};\n\nConcentration.prototype.defer_to = function (player) {\n  var turnTaken = Q.defer(), game = this;\n\n  player.takeTurn()\n  .then(function ($card) {\n    return game.turn.handleChoice(player, $card);\n  })\n  .then(function (nextOrSamePlayer) {\n    var numCards = game.board.numCards;\n\n    game.hud.render(numCards);\n    turnTaken.resolve(nextOrSamePlayer);\n  })\n  .fail(function (err) { throw err; });\n\n  return turnTaken.promise;\n};\n\nConcentration.prototype.endCondition = function () {\n  // Game never ends for now\n  return false;\n};\n\nConcentration.prototype.notice = function (msg) {\n  console.log(msg);\n};\n\n","function Deck () {\n  this.cards = [];\n  this.loadCards();\n}\n\nDeck.prototype.loadCards = function () {\n  var cards = this.cards;\n\n  for (var suit in Card.SUIT_SYMBOLS) {\n    for (var number in Card.NUMBER_SYMBOLS) {\n      var thisCard = new Card(suit, number);\n\n      cards.push(thisCard);\n    }\n  }\n};\n\nDeck.prototype.count = function () {\n  return this.cards.length;\n};\n\nDeck.prototype.shuffle = function () {\n /*\n  * As seen on stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n  */\n  var currentIndex = this.cards.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = this.cards[currentIndex];\n    this.cards[currentIndex] = this.cards[randomIndex];\n    this.cards[randomIndex] = temporaryValue;\n  }\n\n  return this;\n};\n\n","function Graveyard ($el) {\n  this.$el = $el;\n}\n\nGraveyard.prototype.add = function (cardTags) {\n  var $graveyard = this.$el;\n\n  cardTags.forEach(function (cardTag) {\n    var tagClone = cardTag.clone();\n    $graveyard.append(tagClone);\n  });\n};\n\n","function Hud ($el, player1, player2) {\n  this.$el = $el;\n  this.player1 = player1;\n  this.player2 = player2;\n}\n\nHud.prototype.render = function (numCards) {\n  var $remainingCardsSpan = this.remainingCardsSpan(numCards),\n      $player1span = this.playerSpan(this.player1),\n      $player2span = this.playerSpan(this.player2);\n\n  this.$el.html($remainingCardsSpan)\n          .append($player1span)\n          .append($player2span);\n};\n\nHud.prototype.playerSpan = function (player) {\n  var $span = $('<span>'),\n      content = \"Player \" + player.id + \" Matches: \"  + player.numMatches;\n\n  $span.addClass(\"player\" + player.id)\n       .html(content);\n\n  return $span;\n};\n\nHud.prototype.remainingCardsSpan = function (numCards) {\n  return $('<span>').append('Cards remaining: ' + numCards);\n};\n\n","// Inherits from Player class\nfunction HumanPlayer(args) {\n  Player.apply(this, arguments);\n}\n\nHumanPlayer.prototype = Object.create(Player.prototype);\nHumanPlayer.prototype.constructor = Player;\n\nHumanPlayer.prototype.getInput = function () {\n  var clicked = Q.defer();\n  this.board.on('click', function (evnt) {\n    var $card = $(evnt.target);\n\n    // Ignore click if player didn't click a card\n    // Or clicked a revealed card\n    if (!$card.hasClass('card') || !$card.hasClass('hidden')) return;\n\n    this.board.off('click');\n    clicked.resolve($card);\n  }.bind(this));\n\n  return clicked.promise;\n};\n\nHumanPlayer.prototype.confirmNextTurn = function () {\n  var $window = $(window), clicked = Q.defer();\n\n  $window.on('click', function () {\n    clicked.resolve();\n    $window.off('click');\n  });\n\n  return clicked.promise;\n};\n\n","function Inspector (board) {\n  this.board = board;\n  this.flippedCards = [];\n}\n\nInspector.prototype.evaluateChoice = function ($card) {\n  var outcome = \"continue\";\n\n  this.flippedCards.push($card);\n  this.inspect($card);\n  if (this.isShowingMax()) {\n    outcome = this.compareCards();\n  }\n\n  return outcome;\n};\n\nInspector.prototype.compareCards = function () {\n  if (_cardsHaveSameNumber(this.flippedCards)) {\n    // Flush out flipped cards by setting length to 0\n    return \"match\";\n  } else {\n    return \"miss\";\n  }\n\n  // Reduce cards to 'false' unless they all have the same number\n  function _cardsHaveSameNumber (cards) {\n    return !!cards.reduce(function (prevCard, card) {\n      if (prevCard.data && prevCard.data('number') == card.data('number')) {\n        return card;\n      }\n\n      return false;\n    });\n  }\n};\n\nInspector.prototype.inspect = function ($card) {\n  this.board.show($card);\n};\n\nInspector.prototype.isShowingMax = function () {\n  return this.flippedCards.length >= this.constructor.MAX_MATCHES;\n};\n\nInspector.prototype.removeMatches = function (player) {\n  this.board.remove(this.flippedCards, player);\n  this.flush();\n};\n\nInspector.prototype.hideCards = function () {\n  this.flippedCards.forEach(function($card) {\n    this.board.hide($card);\n  }.bind(this));\n\n  this.flush();\n};\n\nInspector.prototype.flush = function () {\n  this.flippedCards.length = 0;\n};\n\nInspector.MAX_MATCHES = 2;\n\n","$(function () {\n  new Concentration().play();\n});\n\n","// Superclass of ComputerPlayer and HumanPlayer\n\nfunction Player (id, board) {\n  this.id = id;\n  this.board = board;\n  this.numMatches = 0;\n}\n\nPlayer.prototype.takeTurn = function () {\n  var turnTaken = Q.defer();\n\n  this.getInput()\n  .then(function ($card) {\n    turnTaken.resolve($card);\n  })\n  .fail(function (err) {\n    throw err;\n  });\n\n  return turnTaken.promise;\n};\n\nPlayer.prototype.recordNewMatch = function () {\n  this.numMatches++;\n};\n\n","function Turn (board, player1, player2) {\n  this.board = board;\n  this.inspector = new Inspector(this.board);\n  this.player1 = player1;\n  this.player2 = player2;\n}\n\nTurn.prototype.handleChoice = function (player, $chosenCard) {\n  var choiceHandled = Q.defer(),\n      currentPlayer = (player == this.player1 ? this.player1 : this.player2),\n      nextPlayer = (player == this.player1 ? this.player2 : this.player1),\n\n      turnOutcome = this.inspector.evaluateChoice($chosenCard);\n\n  switch(turnOutcome) {\n    case \"continue\":\n      // Player keeps going if the max number of cards\n      // hasn't been flipped\n      choiceHandled.resolve(currentPlayer);\n      break;\n    case \"match\":\n      currentPlayer.confirmNextTurn()\n      .then(function () {\n        currentPlayer.recordNewMatch();\n        this.inspector.removeMatches(currentPlayer);\n        choiceHandled.resolve(currentPlayer);\n      }.bind(this))\n      .fail(function (err) { throw err; });\n      break;\n    case \"miss\":\n      currentPlayer.confirmNextTurn()\n      .then(function () {\n        this.inspector.hideCards();\n        choiceHandled.resolve(nextPlayer);\n      }.bind(this))\n      .fail(function (err) { throw err; });\n      break;\n    default:\n      throw new Error(\"Unknown choice outcome\");\n  }\n\n  return choiceHandled.promise;\n};\n\n"],"sourceRoot":"/source/"}