{"version":3,"sources":["player.js","board.js","card.js","computer_player.js","concentration.js","deck.js","game.js","graveyard.js","hud.js","human_player.js","inspector.js","turn.js","lru.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"concentration.all.js","sourcesContent":["(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  // Superclass of ComputerPlayer and HumanPlayer\n  var Player = Concentration.Player = function (id, board) {\n    this.id = id;\n    this.board = board;\n    this.numMatches = 0;\n  };\n\n  Player.prototype.takeTurn = function () {\n    var turnTaken = Q.defer();\n\n    this.getInput()\n    .then(function ($card) {\n      turnTaken.resolve($card);\n    })\n    .fail(function (err) {\n      throw err;\n    });\n\n    return turnTaken.promise;\n  };\n\n  Player.prototype.recordNewMatch = function () {\n    this.numMatches++;\n  };\n})();\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  var Board = Concentration.Board = function ($el, graveyard1, graveyard2) {\n    this.$el = $el;\n    this.graveyard1 = graveyard1;\n    this.graveyard2 = graveyard2;\n    this.deck = new Concentration.Deck().shuffle();\n    this.numCards = this.deck.count();\n  };\n\n  Board.prototype.render = function (content) {\n    this.$el.html(content);\n  };\n\n  Board.prototype.buildCardTags = function () {\n    return this.deck.cards.map(function (card) {\n      return card.htmlTag();\n    });\n  };\n\n  Board.prototype.layCards = function () {\n    var cardTags = this.buildCardTags();\n\n    this.render(cardTags);\n  };\n\n  Board.prototype.show = function ($card) {\n    $card.trigger('showing');\n    $card.removeClass('hidden');\n  };\n\n  Board.prototype.hide = function (cardTag) {\n    cardTag.addClass('hidden');\n  };\n\n  Board.prototype.on = function (evnt, callback) {\n    this.$el.on(evnt, callback);\n  };\n\n  Board.prototype.off = function (evnt) {\n    this.$el.off(evnt);\n  };\n\n  Board.prototype.remove = function ($cards, player) {\n    var graveyard = (player.id == 1 ? this.graveyard1 : this.graveyard2);\n\n    graveyard.add($cards);\n    this.numCards -= $cards.length;\n    $cards.forEach(function ($card) {\n      $card.addClass('removed');\n      $card.trigger('matched');\n    });\n  };\n})();\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n  var Card = Concentration.Card = function (suit, number) {\n    this.suit = suit;\n    this.number = number;\n  };\n\n  Card.prototype.span = function () {\n    return $('<span>').append(this.suitSyms(this.suit))\n                      .append(this.numSyms(this.number));\n  };\n\n  Card.prototype.divTag = function () {\n    var $div = $('<div>');\n    $div.addClass(this.constructor.htmlClass)\n        .addClass('hidden');\n\n    if (this.suit == \"hearts\" || this.suit == \"diamonds\") {\n      $div.addClass('red');\n    }\n\n    $div.data('number', this.number);\n\n    return $div;\n  };\n\n  Card.prototype.htmlTag = function () {\n    var $span = this.span(),\n        divTag = this.divTag();\n\n    divTag.append($span);\n\n    return divTag[0];\n  };\n\n  Card.htmlClass = 'card';\n\n  Card.prototype.suitSyms = function (suit) {\n    return this.constructor.SUIT_SYMBOLS[suit];\n  };\n\n  Card.prototype.numSyms = function (num) {\n    return this.constructor.NUMBER_SYMBOLS[num];\n  };\n\n  Card.SUIT_SYMBOLS = {\n    clubs:    \"&clubs;\",\n    diamonds: \"&diams;\",\n    hearts:   \"&hearts;\",\n    spades:   \"&spades;\"\n  };\n\n  Card.NUMBER_SYMBOLS = {\n    two:   \"2\",\n    three: \"3\",\n    four:  \"4\",\n    five:  \"5\",\n    six:   \"6\",\n    seven: \"7\",\n    eight: \"8\",\n    nine:  \"9\",\n    ten:   \"10\",\n    jack:  \"J\",\n    queen: \"Q\",\n    king : \"K\",\n    ace  : \"A\"\n  };\n})();\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  var ComputerPlayer = Concentration.ComputerPlayer = function ($cards, memoryLimit, args) {\n    Concentration.Player.apply(this, [].slice.call(arguments, 2));\n    this.$cards = $cards;\n    this.memory = new LRUCache(memoryLimit);\n    this.watchCards();\n  };\n\n  // Same inheritance problem as with HumanPlayer\n  ComputerPlayer.prototype = Object.create(Concentration.Player.prototype);\n  ComputerPlayer.prototype.constructor = ComputerPlayer;\n\n  ComputerPlayer.prototype.getInput = function () {\n    var chose = Q.defer(), chosenCard;\n\n    chosenCard = this.findMatchInMemory();\n\n    if (!chosenCard) {\n      // Pick a random, non-hidden card if no matches found\n      var  $availableCards = this.$cards.filter('.hidden');\n      chosenCard = $availableCards[Math.floor(Math.random() * $availableCards.length)];\n    }\n\n    setTimeout(function () {\n      chose.resolve($(chosenCard));\n    }, this.constructor.THINK_TIME);\n\n    return chose.promise;\n  };\n\n  ComputerPlayer.prototype.confirmNextTurn = function () {\n    var confirmed = Q.defer();\n\n    setTimeout(function () {\n      confirmed.resolve();\n    }, this.constructor.THINK_TIME);\n\n    return confirmed.promise;\n  };\n\n  ComputerPlayer.prototype.watchCards = function () {\n    this.$cards.on('showing', function (evnt) {\n      var card = evnt.target,\n          cardNumber = $(card).data('number');\n\n      // For some reason removed cards still\n      // appear in the matching loop\n      this.memory.put(card, cardNumber);\n    }.bind(this));\n\n    this.$cards.on('matched', function (evnt) {\n      var card = evnt.target;\n\n      this.memory.remove(card);\n    }.bind(this));\n  };\n\n  ComputerPlayer.prototype.findMatchInMemory = function () {\n    var seenCards = {}, foundCard;\n    this.memory.forEach(function (card, number) {\n      // Dirty fix to removal problem:\n      // Skip cards here that are already removed\n      if ($(card).hasClass('removed')) {\n      } else if (seenCards[number] && seenCards[number] != card) {\n        var hiddenCard = ($(card).hasClass('hidden') ? card : seenCards[number]);\n        foundCard = hiddenCard;\n      } else {\n        seenCards[number] = card;\n      }\n    });\n\n    return foundCard;\n  };\n\n  ComputerPlayer.THINK_TIME = 1000;\n})();\n\n","$(function () {\n  new Concentration.Game().start();\n});\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  var Deck = Concentration.Deck = function () {\n    this.cards = [];\n    this.loadCards();\n  };\n\n  Deck.prototype.loadCards = function () {\n    var cards = this.cards;\n\n    for (var suit in Concentration.Card.SUIT_SYMBOLS) {\n      for (var number in Concentration.Card.NUMBER_SYMBOLS) {\n        var thisCard = new Concentration.Card(suit, number);\n\n        cards.push(thisCard);\n      }\n    }\n  };\n\n  Deck.prototype.count = function () {\n    return this.cards.length;\n  };\n\n  Deck.prototype.shuffle = function () {\n   /*\n    * As seen on stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n    */\n    var currentIndex = this.cards.length, temporaryValue, randomIndex;\n\n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n\n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n\n      // And swap it with the current element.\n      temporaryValue = this.cards[currentIndex];\n      this.cards[currentIndex] = this.cards[randomIndex];\n      this.cards[randomIndex] = temporaryValue;\n    }\n\n    return this;\n  };\n})();\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n  \n  var Game = Concentration.Game = function () {\n    this.board = null;\n    this.initBoard();\n\n    this.player1 = null;\n    this.player2 = null;\n    this.initPlayers();\n\n    this.turn = new Concentration.Turn(this.board, this.player1, this.player2);\n    this.hud = null;\n    this.initHud();\n  };\n\n  Game.prototype.initBoard = function () {\n    var $boardEl = $('.board'),\n        $graveyard1El = $('.graveyard#one'),\n        $graveyard2El = $('.graveyard#two'),\n        graveyard1 = new Concentration.Graveyard($graveyard1El);\n        graveyard2 = new Concentration.Graveyard($graveyard2El);\n\n    this.board = new Concentration.Board($boardEl, graveyard1, graveyard2);\n    this.board.layCards();\n  };\n\n  Game.prototype.initPlayers = function () {\n    var $cards = $('.card');\n\n    this.player1 = new Concentration.HumanPlayer(1, this.board);\n    //this.player2 = new Concentration.HumanPlayer(2, this.board);\n    //this.player1 = new Concentration.ComputerPlayer($cards, 20, 1, this.board);\n    this.player2 = new Concentration.ComputerPlayer($cards, 20, 2, this.board);\n  };\n\n  Game.prototype.initHud = function () {\n    var $hud = $('.hud');\n\n    this.hud = new Concentration.Hud($hud, this.player1, this.player2);\n    this.hud.render(this.board.numCards);\n  };\n\n  Game.prototype.start = function () {\n    this.play()\n        .then(function () {\n          var msg = this.gameEndMessage();\n          this.hud.announceWinner(msg);\n        }.bind(this))\n        .fail(function (err) { throw err; });\n  };\n\n  Game.prototype.gameEndMessage = function () {\n      var player1Score = this.player1.numMatches,\n          player2Score = this.player2.numMatches;\n\n      if (player1Score > player2Score) {\n        return \"Player 1 wins\";\n      } else if (player2Score > player1Score) {\n        return \"Player 2 wins\";\n      } else {\n        return \"Draw\";\n      }\n  };\n\n  Game.prototype.play = function () {\n    var game = this,\n        gameOver = Q.defer();\n\n    _prompt(this.player1);\n\n    return gameOver.promise;\n\n    function _prompt(currentPlayer) {\n      if (game.endCondition()) return gameOver.resolve();\n\n      game.defer_to(currentPlayer)\n      .then(function (nextOrSamePlayer) {\n        _prompt(nextOrSamePlayer);\n      })\n      .fail(function (err) { throw err; });\n    }\n  };\n\n  Game.prototype.defer_to = function (player) {\n    var turnTaken = Q.defer(), game = this;\n\n    player.takeTurn()\n    .then(function ($card) {\n      return game.turn.handleChoice(player, $card);\n    })\n    .then(function (nextOrSamePlayer) {\n      var numCards = game.board.numCards;\n\n      game.hud.render(numCards, nextOrSamePlayer);\n      turnTaken.resolve(nextOrSamePlayer);\n    })\n    .fail(function (err) { throw err; });\n\n    return turnTaken.promise;\n  };\n\n  Game.prototype.endCondition = function () {\n    return !this.board.numCards;\n  };\n})();\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  var Graveyard = Concentration.Graveyard = function ($el) {\n    this.$el = $el;\n  };\n\n  Graveyard.prototype.add = function (cardTags) {\n    var $graveyard = this.$el;\n\n    cardTags.forEach(function (cardTag) {\n      var tagClone = cardTag.clone();\n      $graveyard.append(tagClone);\n    });\n  };\n})();\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  var Hud = Concentration.Hud = function ($el, player1, player2) {\n    this.$el = $el;\n    this.player1 = player1;\n    this.player2 = player2;\n  };\n\n  Hud.prototype.render = function (numCards, currentPlayer) {\n    var $remainingCardsSpan = this.remainingCardsSpan(numCards),\n        $player1span = this.playerSpan(this.player1),\n        $player2span = this.playerSpan(this.player2);\n\n    if (currentPlayer) {\n      var $currentPlayerSpan = (currentPlayer == this.player1 ? $player1span : $player2span);\n      $currentPlayerSpan.addClass('active');\n    }\n\n    this.$el.html($remainingCardsSpan)\n            .append($player1span)\n            .append($player2span);\n  };\n\n  Hud.prototype.playerSpan = function (player) {\n    var $span = $('<span>'),\n        content = \"Player \" + player.id + \" Matches: \"  + player.numMatches;\n\n    $span.addClass(\"player\" + player.id)\n         .html(content);\n\n    return $span;\n  };\n\n  Hud.prototype.remainingCardsSpan = function (numCards) {\n    return $('<span>').append('Cards remaining: ' + numCards);\n  };\n\n  Hud.prototype.announceWinner = function (msg) {\n    var $span = $('<span>');\n    $span.html(msg);\n\n    this.$el.html($span);\n  };\n})();\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  // Inherits from Player class\n  var HumanPlayer = Concentration.HumanPlayer = function (args) {\n    Concentration.Player.apply(this, arguments);\n  };\n\n  // Not ideal because Player class must be declared first.\n  // Can't wait for doc ready either lest HumanPlayer proto gets overriden\n  // Investigate more flexible inheritance\n  HumanPlayer.prototype = Object.create(Concentration.Player.prototype);\n  HumanPlayer.prototype.constructor = HumanPlayer;\n\n  HumanPlayer.prototype.getInput = function () {\n    var clicked = Q.defer();\n    this.board.on('click', function (evnt) {\n      var $card = $(evnt.target);\n\n      // Ignore click if player didn't click a card\n      // Or clicked a revealed card\n      if (!$card.hasClass('card') || !$card.hasClass('hidden')) return;\n\n      this.board.off('click');\n      clicked.resolve($card);\n    }.bind(this));\n\n    return clicked.promise;\n  };\n\n  HumanPlayer.prototype.confirmNextTurn = function () {\n    var $window = $(window), clicked = Q.defer();\n\n    $window.on('click', function () {\n      clicked.resolve();\n      $window.off('click');\n    });\n\n    return clicked.promise;\n  };\n})();\n\n","(function () {\n   if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  var Inspector = Concentration.Inspector = function (board) {\n    this.board = board;\n    this.flippedCards = [];\n  };\n\n  Inspector.prototype.evaluateChoice = function ($card) {\n    var outcome = \"continue\";\n\n    this.flippedCards.push($card);\n    this.inspect($card);\n    if (this.isShowingMax()) {\n      outcome = this.compareCards();\n    }\n\n    return outcome;\n  };\n\n  Inspector.prototype.compareCards = function () {\n    if (_cardsHaveSameNumber(this.flippedCards)) {\n      // Flush out flipped cards by setting length to 0\n      return \"match\";\n    } else {\n      return \"miss\";\n    }\n\n    // Reduce cards to 'false' unless they all have the same number\n    function _cardsHaveSameNumber (cards) {\n      return !!cards.reduce(function (prevCard, card) {\n        if (prevCard.data && prevCard.data('number') == card.data('number')) {\n          return card;\n        }\n\n        return false;\n      });\n    }\n  };\n\n  Inspector.prototype.inspect = function ($card) {\n    this.board.show($card);\n  };\n\n  Inspector.prototype.isShowingMax = function () {\n    return this.flippedCards.length >= this.constructor.MAX_MATCHES;\n  };\n\n  Inspector.prototype.removeMatches = function (player) {\n    this.board.remove(this.flippedCards, player);\n    this.flush();\n  };\n\n  Inspector.prototype.hideCards = function () {\n    this.flippedCards.forEach(function($card) {\n      this.board.hide($card);\n    }.bind(this));\n\n    this.flush();\n  };\n\n  Inspector.prototype.flush = function () {\n    this.flippedCards.length = 0;\n  };\n\n  Inspector.MAX_MATCHES = 2;\n})();\n\n","(function () {\n  if (typeof Concentration === \"undefined\") window.Concentration = {};\n\n  var Turn = Concentration.Turn = function (board, player1, player2) {\n    this.board = board;\n    this.inspector = new Concentration.Inspector(this.board);\n    this.player1 = player1;\n    this.player2 = player2;\n  };\n\n  Turn.prototype.handleChoice = function (player, $chosenCard) {\n    var choiceHandled = Q.defer(),\n        currentPlayer = (player == this.player1 ? this.player1 : this.player2),\n        nextPlayer = (player == this.player1 ? this.player2 : this.player1),\n\n        turnOutcome = this.inspector.evaluateChoice($chosenCard);\n\n    switch(turnOutcome) {\n      case \"continue\":\n        // Player keeps going if the max number of cards\n        // hasn't been flipped\n        choiceHandled.resolve(currentPlayer);\n        break;\n      case \"match\":\n        currentPlayer.confirmNextTurn()\n        .then(function () {\n          currentPlayer.recordNewMatch();\n          this.inspector.removeMatches(currentPlayer);\n          choiceHandled.resolve(currentPlayer);\n        }.bind(this))\n        .fail(function (err) { throw err; });\n        break;\n      case \"miss\":\n        currentPlayer.confirmNextTurn()\n        .then(function () {\n          this.inspector.hideCards();\n          choiceHandled.resolve(nextPlayer);\n        }.bind(this))\n        .fail(function (err) { throw err; });\n        break;\n      default:\n        throw new Error(\"Unknown choice outcome\");\n    }\n\n    return choiceHandled.promise;\n  };\n})();\n\n","/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\nfunction LRUCache (limit) {\n  // Current size of the cache. (Read-only).\n  this.size = 0;\n  // Maximum number of items this cache can hold.\n  this.limit = limit;\n  this._keymap = {};\n}\n\n/**\n * Put <value> into the cache associated with <key>. Returns the entry which was\n * removed to make room for the new entry. Otherwise undefined is returned\n * (i.e. if there was enough room already).\n */\nLRUCache.prototype.put = function(key, value) {\n  var entry = {key:key, value:value};\n  // Note: No protection agains replacing, and thus orphan entries. By design.\n  this._keymap[key] = entry;\n  if (this.tail) {\n    // link previous tail to the new tail (entry)\n    this.tail.newer = entry;\n    entry.older = this.tail;\n  } else {\n    // we're first in -- yay\n    this.head = entry;\n  }\n  // add new entry to the end of the linked list -- it's now the freshest entry.\n  this.tail = entry;\n  if (this.size === this.limit) {\n    // we hit the limit -- remove the head\n    return this.shift();\n  } else {\n    // increase the size counter\n    this.size++;\n  }\n};\n\n/**\n * Purge the least recently used (oldest) entry from the cache. Returns the\n * removed entry or undefined if the cache was empty.\n *\n * If you need to perform any form of finalization of purged items, this is a\n * good place to do it. Simply override/replace this function:\n *\n *   var c = new LRUCache(123);\n *   c.shift = function() {\n *     var entry = LRUCache.prototype.shift.call(this);\n *     doSomethingWith(entry);\n *     return entry;\n *   }\n */\nLRUCache.prototype.shift = function() {\n  // todo: handle special case when limit == 1\n  var entry = this.head;\n  if (entry) {\n    if (this.head.newer) {\n      this.head = this.head.newer;\n      this.head.older = undefined;\n    } else {\n      this.head = undefined;\n    }\n    // Remove last strong reference to <entry> and remove links from the purged\n    // entry being returned:\n    entry.newer = entry.older = undefined;\n    // delete is slow, but we need to do this to avoid uncontrollable growth:\n    delete this._keymap[entry.key];\n  }\n  return entry;\n};\n\n/**\n * Get and register recent use of <key>. Returns the value associated with <key>\n * or undefined if not in cache.\n */\nLRUCache.prototype.get = function(key, returnEntry) {\n  // First, find our cache entry\n  var entry = this._keymap[key];\n  if (entry === undefined) return; // Not cached. Sorry.\n  // As <key> was found in the cache, register it as being requested recently\n  if (entry === this.tail) {\n    // Already the most recenlty used entry, so no need to update the list\n    return returnEntry ? entry : entry.value;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head)\n      this.head = entry.newer;\n    entry.newer.older = entry.older; // C <-- E.\n  }\n  if (entry.older)\n    entry.older.newer = entry.newer; // C. --> E\n  entry.newer = undefined; // D --x\n  entry.older = this.tail; // D. --> E\n  if (this.tail)\n    this.tail.newer = entry; // E. <-- D\n  this.tail = entry;\n  return returnEntry ? entry : entry.value;\n};\n\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n\n/**\n * Check if <key> is in the cache without registering recent use. Feasible if\n * you do not want to chage the state of the cache, but only \"peek\" at it.\n * Returns the entry associated with <key> if found, or undefined if not found.\n */\nLRUCache.prototype.find = function(key) {\n  return this._keymap[key];\n};\n\n/**\n * Update the value of entry with <key>. Returns the old value, or undefined if\n * entry was not in the cache.\n */\nLRUCache.prototype.set = function(key, value) {\n  var oldvalue, entry = this.get(key, true);\n  if (entry) {\n    oldvalue = entry.value;\n    entry.value = value;\n  } else {\n    oldvalue = this.put(key, value);\n    if (oldvalue) oldvalue = oldvalue.value;\n  }\n  return oldvalue;\n};\n\n/**\n * Remove entry <key> from cache and return its value. Returns undefined if not\n * found.\n */\nLRUCache.prototype.remove = function(key) {\n  var entry = this._keymap[key];\n  if (!entry) return;\n  delete this._keymap[entry.key]; // need to do delete unfortunately\n  if (entry.newer && entry.older) {\n    // relink the older entry with the newer entry\n    entry.older.newer = entry.newer;\n    entry.newer.older = entry.older;\n  } else if (entry.newer) {\n    // remove the link to us\n    entry.newer.older = undefined;\n    // link the newer entry to head\n    this.head = entry.newer;\n  } else if (entry.older) {\n    // remove the link to us\n    entry.older.newer = undefined;\n    // link the newer entry to head\n    this.tail = entry.older;\n  } else {// if(entry.older === undefined && entry.newer === undefined) {\n    this.head = this.tail = undefined;\n  }\n\n  this.size--;\n  return entry.value;\n};\n\n/** Removes all entries */\nLRUCache.prototype.removeAll = function() {\n  // This should be safe, as we never expose strong refrences to the outside\n  this.head = this.tail = undefined;\n  this.size = 0;\n  this._keymap = {};\n};\n\n/**\n * Return an array containing all keys of entries stored in the cache object, in\n * arbitrary order.\n */\nif (typeof Object.keys === 'function') {\n  LRUCache.prototype.keys = function() { return Object.keys(this._keymap); };\n} else {\n  LRUCache.prototype.keys = function() {\n    var keys = [];\n    for (var k in this._keymap) keys.push(k);\n    return keys;\n  };\n}\n\n/**\n * Call `fun` for each entry. Starting with the newest entry if `desc` is a true\n * value, otherwise starts with the oldest (head) enrty and moves towards the\n * tail.\n *\n * `fun` is called with 3 arguments in the context `context`:\n *   `fun.call(context, Object key, Object value, LRUCache self)`\n */\nLRUCache.prototype.forEach = function(fun, context, desc) {\n  var entry;\n  if (context === true) { desc = true; context = undefined; }\n  else if (typeof context !== 'object') context = this;\n  if (desc) {\n    entry = this.tail;\n    while (entry) {\n      fun.call(context, entry.key, entry.value, this);\n      entry = entry.older;\n    }\n  } else {\n    entry = this.head;\n    while (entry) {\n      fun.call(context, entry.key, entry.value, this);\n      entry = entry.newer;\n    }\n  }\n};\n\n/** Returns a JSON (array) representation */\nLRUCache.prototype.toJSON = function() {\n  var s = [], entry = this.head;\n  while (entry) {\n    s.push({key:entry.key.toJSON(), value:entry.value.toJSON()});\n    entry = entry.newer;\n  }\n  return s;\n};\n\n/** Returns a String representation */\nLRUCache.prototype.toString = function() {\n  var s = '', entry = this.head;\n  while (entry) {\n    s += String(entry.key)+':'+entry.value;\n    entry = entry.newer;\n    if (entry)\n      s += ' < ';\n  }\n  return s;\n};\n\n// Export ourselves\nif (typeof this === 'object') this.LRUCache = LRUCache;"],"sourceRoot":"/source/"}