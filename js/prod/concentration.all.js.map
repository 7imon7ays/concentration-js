{"version":3,"sources":["board.js","card.js","computer_player.js","concentration.js","deck.js","graveyard.js","human_player.js","inspector.js","player.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"concentration.all.js","sourcesContent":["function Board($el, graveyard) {\n  this.$el = $el;\n  this.graveyard = graveyard;\n  this.deck = new Deck().shuffle();\n  this.numCards = this.deck.count();\n}\n\nBoard.prototype.render = function (content) {\n  this.$el.html(content);\n};\n\nBoard.prototype.buildCardTags = function () {\n  return this.deck.cards.map(function (card) {\n    return card.htmlTag();\n  });\n};\n\nBoard.prototype.layCards = function () {\n  var cardTags = this.buildCardTags();\n\n  this.render(cardTags);\n};\n\nBoard.prototype.show = function (cardTag) {\n  cardTag.removeClass('hidden');\n};\n\nBoard.prototype.hide = function (cardTag) {\n  cardTag.addClass('hidden');\n};\n\nBoard.prototype.on = function (evnt, callback) {\n  this.$el.on(evnt, callback);\n};\n\nBoard.prototype.off = function (evnt) {\n  this.$el.off(evnt);\n};\n\nBoard.prototype.remove = function (cardTags) {\n  this.graveyard.add(cardTags);\n  this.numCards -= cardTags.length;\n  cardTags.forEach(function (cardTag) {\n    cardTag.addClass('removed');\n  });\n};\n\n","function Card (suit, number) {\n  this.suit = suit;\n  this.number = number;\n}\n\nCard.prototype.spanTag = function () {\n  return $('<span>').append(this.suitSyms(this.suit))\n                    .append(this.numSyms(this.number));\n};\n\nCard.prototype.divTag = function () {\n  var $div = $('<div>');\n  $div.addClass(this.constructor.htmlClass)\n      .addClass('hidden');\n\n  if (this.suit == \"hearts\" || this.suit == \"diamonds\") {\n    $div.addClass('red');\n  }\n\n  $div.data('number', this.number);\n\n  return $div;\n};\n\nCard.prototype.htmlTag = function () {\n  var spanTag = this.spanTag(),\n      divTag = this.divTag();\n\n  divTag.append(spanTag);\n\n  return divTag[0];\n};\n\nCard.htmlClass = 'card';\n\nCard.prototype.suitSyms = function (suit) {\n  return this.constructor.SUIT_SYMBOLS[suit];\n};\n\nCard.prototype.numSyms = function (num) {\n  return this.constructor.NUMBER_SYMBOLS[num];\n};\n\nCard.SUIT_SYMBOLS = {\n  clubs:    \"&clubs;\",\n  diamonds: \"&diams;\",\n  hearts:   \"&hearts;\",\n  spades:   \"&spades;\"\n};\n\nCard.NUMBER_SYMBOLS = {\n  two:   \"2\",\n  three: \"3\",\n};\n\n/*\n  four:  \"4\",\n  five:  \"5\",\n  six:   \"6\",\n  seven: \"7\",\n  eight: \"8\",\n  nine:  \"9\",\n  ten:   \"10\",\n  jack:  \"J\",\n  queen: \"Q\",\n  king : \"K\",\n  ace  : \"A\"\n  */\n","function ComputerPlayer ($cards, args) {\n  Player.apply(this, [].slice.call(arguments, 1));\n  this.$cards = $cards;\n}\n\nComputerPlayer.prototype = Object.create(Player.prototype);\nComputerPlayer.prototype.constructor = ComputerPlayer;\n\nComputerPlayer.prototype.getInput = function () {\n  var chose = Q.defer(),\n      $availableCards = this.$cards.filter('.hidden');\n      // Just pick a random, non-hidden card for now\n      chosenCard = $availableCards[Math.floor(Math.random() *\n          $availableCards.length)];\n\n  setTimeout(function () {\n    chose.resolve($(chosenCard));\n  }, this.constructor.THINK_TIME);\n\n  return chose.promise;\n};\n\nComputerPlayer.prototype.confirmNextTurn = function () {\n  var confirmed = Q.defer();\n\n  setTimeout(function () {\n    confirmed.resolve();\n  }, this.constructor.THINK_TIME);\n\n  return confirmed.promise;\n};\n\nComputerPlayer.THINK_TIME = 1000;\n\n","function Concentration () {\n  this.board = null;\n  this.initBoard();\n\n  this.inspector = new Inspector(this.board);\n\n  this.player1 = null;\n  this.player2 = null;\n  this.initPlayers();\n}\n\nConcentration.prototype.initBoard = function () {\n  var $boardEl = $('.board'),\n      $graveyardEl = $('.graveyard'),\n      graveyard = new Graveyard($graveyardEl);\n\n  this.board = new Board($boardEl, graveyard);\n  this.board.layCards();\n};\n\nConcentration.prototype.initPlayers = function () {\n  var $cards = $('.card');\n\n  this.player1 = new HumanPlayer(1, this.board);\n  this.player2 = new ComputerPlayer($cards, 2, this.board);\n};\n\nConcentration.prototype.play = function () {\n  var game = this;\n  var gameOver = Q.defer();\n\n  _invite(this.player1);\n\n  function _invite(currentPlayer) {\n    game.notice('Waiting on: Player ' + currentPlayer.id);\n    if (game.endCondition()) return gameOver.resolve();\n\n    game.turn(currentPlayer)\n    .then(function (nextPlayer) {\n      _invite(nextPlayer);\n    })\n    .fail(function (err) { throw err; });\n  }\n\n  return gameOver.promise;\n};\n\nConcentration.prototype.turn = function (player) {\n  var madeMove = Q.defer();\n\n  player.takeTurn()\n  .then(function ($card) {\n    this.handleChoice(player, $card, madeMove);\n  }.bind(this))\n  .fail(function (err) { throw err; });\n\n  return madeMove.promise;\n};\n\nConcentration.prototype.handleChoice = function (player, $chosenCard, completedPromise) {\n  var currentPlayer = (player == this.player1 ? this.player1 : this.player2),\n      nextPlayer = (player == this.player1 ? this.player2 : this.player1);\n\n  var turnOutcome = this.inspector.evaluateChoice($chosenCard);\n\n  switch(turnOutcome) {\n    case \"continue\":\n      // Player keeps going if the max number of cards\n      // hasn't been flipped\n      completedPromise.resolve(currentPlayer);\n      break;\n    case \"match\":\n      currentPlayer.confirmNextTurn()\n      .then(function () {\n        this.inspector.removeMatches();\n        completedPromise.resolve(currentPlayer);\n      }.bind(this))\n      .fail(function (err) { throw err; });\n      break;\n    case \"miss\":\n      currentPlayer.confirmNextTurn()\n      .then(function () {\n        this.inspector.hideCards();\n        completedPromise.resolve(nextPlayer);\n      }.bind(this))\n      .fail(function (err) { throw err; });\n      break;\n    default:\n      throw new Error(\"Unknown choice outcome\");\n  }\n};\n\nConcentration.prototype.endCondition = function () {\n  // Game never ends for now\n  return false;\n};\n\nConcentration.prototype.notice = function (msg) {\n  console.log(msg);\n};\n\n$(function () {\n  new Concentration().play();\n});\n\n","function Deck () {\n  this.cards = [];\n  this.loadCards();\n}\n\nDeck.prototype.loadCards = function () {\n  var cards = this.cards;\n\n  for (var suit in Card.SUIT_SYMBOLS) {\n    for (var number in Card.NUMBER_SYMBOLS) {\n      var thisCard = new Card(suit, number);\n\n      cards.push(thisCard);\n    }\n  }\n};\n\nDeck.prototype.count = function () {\n  return this.cards.length;\n};\n\nDeck.prototype.shuffle = function () {\n /*\n  * As seen on stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n  */\n  var currentIndex = this.cards.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = this.cards[currentIndex];\n    this.cards[currentIndex] = this.cards[randomIndex];\n    this.cards[randomIndex] = temporaryValue;\n  }\n\n  return this;\n};\n\n","function Graveyard ($el) {\n  this.$el = $el;\n}\n\nGraveyard.prototype.add = function (cardTags) {\n  var $graveyard = this.$el;\n\n  cardTags.forEach(function (cardTag) {\n    var tagClone = cardTag.clone();\n    $graveyard.append(tagClone);\n  });\n};\n\n","// Inherits from Player class\nfunction HumanPlayer(args) {\n  Player.apply(this, arguments);\n}\n\nHumanPlayer.prototype = Object.create(Player.prototype);\nHumanPlayer.prototype.constructor = Player;\n\nHumanPlayer.prototype.getInput = function () {\n  var clicked = Q.defer();\n  this.board.on('click', function (evnt) {\n    var $card = $(evnt.target);\n\n    // Ignore click if player didn't click a card\n    // Or clicked a revealed card\n    if (!$card.hasClass('card') || !$card.hasClass('hidden')) return;\n\n    this.board.off('click');\n    clicked.resolve($card);\n  }.bind(this));\n\n  return clicked.promise;\n};\n\nHumanPlayer.prototype.confirmNextTurn = function () {\n  var $window = $(window), clicked = Q.defer();\n\n  $window.on('click', function () {\n    clicked.resolve();\n    $window.off('click');\n  });\n\n  return clicked.promise;\n};\n\n","function Inspector (board) {\n  this.board = board;\n  this.flippedCards = [];\n}\n\nInspector.prototype.evaluateChoice = function ($card) {\n  var outcome = \"continue\";\n\n  this.flippedCards.push($card);\n  this.inspect($card);\n  if (this.isShowingMax()) {\n    outcome = this.compareCards();\n  }\n\n  return outcome;\n};\n\nInspector.prototype.compareCards = function () {\n  if (_cardsHaveSameNumber(this.flippedCards)) {\n    // Flush out flipped cards by setting length to 0\n    return \"match\";\n  } else {\n    return \"miss\";\n  }\n\n  // Reduce cards to 'false' unless they all have the same number\n  function _cardsHaveSameNumber (cards) {\n    return !!cards.reduce(function (prevCard, card) {\n      if (prevCard.data && prevCard.data('number') == card.data('number')) {\n        return card;\n      }\n\n      return false;\n    });\n  }\n};\n\nInspector.prototype.inspect = function ($card) {\n  this.board.show($card);\n};\n\nInspector.prototype.isShowingMax = function () {\n  return this.flippedCards.length >= this.constructor.MAX_MATCHES;\n};\n\nInspector.prototype.removeMatches = function () {\n  this.board.remove(this.flippedCards);\n  this.flush();\n};\n\nInspector.prototype.hideCards = function () {\n  this.flippedCards.forEach(function($card) {\n    this.board.hide($card);\n  }.bind(this));\n\n  this.flush();\n};\n\nInspector.prototype.flush = function () {\n  this.flippedCards.length = 0;\n};\n\nInspector.MAX_MATCHES = 2;\n\n","// Superclass of ComputerPlayer and HumanPlayer\n\nfunction Player (id, board) {\n  this.id = id;\n  this.board = board;\n}\n\nPlayer.prototype.takeTurn = function () {\n  var turnTaken = Q.defer();\n\n  this.getInput()\n  .then(function ($card) {\n    turnTaken.resolve($card);\n  })\n  .fail(function (err) {\n    throw err;\n  });\n\n  return turnTaken.promise;\n};\n\n"],"sourceRoot":"/source/"}