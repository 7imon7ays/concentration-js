{"version":3,"sources":["board.js","card.js","computer_player.js","concentration.js","deck.js","graveyard.js","hud.js","human_player.js","inspector.js","main.js","player.js","turn.js","lru.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"concentration.all.js","sourcesContent":["function Board($el, graveyard1, graveyard2) {\n  this.$el = $el;\n  this.graveyard1 = graveyard1;\n  this.graveyard2 = graveyard2;\n  this.deck = new Deck().shuffle();\n  this.numCards = this.deck.count();\n}\n\nBoard.prototype.render = function (content) {\n  this.$el.html(content);\n};\n\nBoard.prototype.buildCardTags = function () {\n  return this.deck.cards.map(function (card) {\n    return card.htmlTag();\n  });\n};\n\nBoard.prototype.layCards = function () {\n  var cardTags = this.buildCardTags();\n\n  this.render(cardTags);\n};\n\nBoard.prototype.show = function ($card) {\n  $card.trigger('showing');\n  $card.removeClass('hidden');\n};\n\nBoard.prototype.hide = function (cardTag) {\n  cardTag.addClass('hidden');\n};\n\nBoard.prototype.on = function (evnt, callback) {\n  this.$el.on(evnt, callback);\n};\n\nBoard.prototype.off = function (evnt) {\n  this.$el.off(evnt);\n};\n\nBoard.prototype.remove = function ($cards, player) {\n  var graveyard = (player.id == 1 ? this.graveyard1 : this.graveyard2);\n\n  graveyard.add($cards);\n  this.numCards -= $cards.length;\n  $cards.forEach(function ($cardTags) {\n    $cardTags.addClass('removed');\n  });\n};\n\n","function Card (suit, number) {\n  this.suit = suit;\n  this.number = number;\n}\n\nCard.prototype.span = function () {\n  return $('<span>').append(this.suitSyms(this.suit))\n                    .append(this.numSyms(this.number));\n};\n\nCard.prototype.divTag = function () {\n  var $div = $('<div>');\n  $div.addClass(this.constructor.htmlClass)\n      .addClass('hidden');\n\n  if (this.suit == \"hearts\" || this.suit == \"diamonds\") {\n    $div.addClass('red');\n  }\n\n  $div.data('number', this.number);\n\n  return $div;\n};\n\nCard.prototype.htmlTag = function () {\n  var $span = this.span(),\n      divTag = this.divTag();\n\n  divTag.append($span);\n\n  return divTag[0];\n};\n\nCard.htmlClass = 'card';\n\nCard.prototype.suitSyms = function (suit) {\n  return this.constructor.SUIT_SYMBOLS[suit];\n};\n\nCard.prototype.numSyms = function (num) {\n  return this.constructor.NUMBER_SYMBOLS[num];\n};\n\nCard.SUIT_SYMBOLS = {\n  clubs:    \"&clubs;\",\n  diamonds: \"&diams;\",\n  hearts:   \"&hearts;\",\n  spades:   \"&spades;\"\n};\n\nCard.NUMBER_SYMBOLS = {\n  two:   \"2\",\n  three: \"3\",\n  four:  \"4\",\n  five:  \"5\",\n  six:   \"6\",\n  seven: \"7\",\n  eight: \"8\",\n  nine:  \"9\",\n  ten:   \"10\",\n  jack:  \"J\",\n  queen: \"Q\",\n  king : \"K\",\n  ace  : \"A\"\n};\n\n","function ComputerPlayer ($cards, args) {\n  Player.apply(this, [].slice.call(arguments, 1));\n  this.$cards = $cards;\n  this.memory = new LRUCache(5);\n  this.watchCards();\n}\n\nComputerPlayer.prototype = Object.create(Player.prototype);\nComputerPlayer.prototype.constructor = ComputerPlayer;\n\nComputerPlayer.prototype.getInput = function () {\n  var chose = Q.defer(),\n      $availableCards = this.$cards.filter('.hidden');\n      // Just pick a random, non-hidden card for now\n      chosenCard = $availableCards[Math.floor(Math.random() *\n          $availableCards.length)];\n\n  setTimeout(function () {\n    chose.resolve($(chosenCard));\n  }, this.constructor.THINK_TIME);\n\n  return chose.promise;\n};\n\nComputerPlayer.prototype.confirmNextTurn = function () {\n  var confirmed = Q.defer();\n\n  setTimeout(function () {\n    confirmed.resolve();\n  }, this.constructor.THINK_TIME);\n\n  return confirmed.promise;\n};\n\nComputerPlayer.prototype.watchCards = function () {\n  this.$cards.on('showing', function (evnt) {\n    var $card = $(evnt.target),\n        cardNumber = $card.data('number');\n\n    this.memory.put($card, cardNumber);\n  }.bind(this));\n};\n\nComputerPlayer.THINK_TIME = 1000;\n\n","function Concentration () {\n  this.board = null;\n  this.initBoard();\n\n  this.player1 = null;\n  this.player2 = null;\n  this.initPlayers();\n\n  this.turn = new Turn(this.board, this.player1, this.player2);\n  this.hud = null;\n  this.initHud();\n}\n\nConcentration.prototype.initBoard = function () {\n  var $boardEl = $('.board'),\n      $graveyard1El = $('.graveyard#one'),\n      $graveyard2El = $('.graveyard#two'),\n      graveyard1 = new Graveyard($graveyard1El);\n      graveyard2 = new Graveyard($graveyard2El);\n\n  this.board = new Board($boardEl, graveyard1, graveyard2);\n  this.board.layCards();\n};\n\nConcentration.prototype.initPlayers = function () {\n  var $cards = $('.card');\n\n  this.player1 = new HumanPlayer(1, this.board);\n  this.player2 = new ComputerPlayer($cards, 2, this.board);\n  //this.player2 = new HumanPlayer(2, this.board);\n};\n\nConcentration.prototype.initHud = function () {\n  var $hud = $('.hud');\n\n  this.hud = new Hud($hud, this.player1, this.player2);\n  this.hud.render(this.board.numCards);\n};\n\nConcentration.prototype.play = function () {\n  var game = this,\n      gameOver = Q.defer();\n\n  _prompt(this.player1);\n\n  return gameOver.promise;\n\n  function _prompt(currentPlayer) {\n    game.notice('Waiting on: Player ' + currentPlayer.id);\n\n    if (game.endCondition()) return gameOver.resolve();\n\n    game.defer_to(currentPlayer)\n    .then(function (nextOrSamePlayer) {\n      _prompt(nextOrSamePlayer);\n    })\n    .fail(function (err) { throw err; });\n  }\n};\n\nConcentration.prototype.defer_to = function (player) {\n  var turnTaken = Q.defer(), game = this;\n\n  player.takeTurn()\n  .then(function ($card) {\n    return game.turn.handleChoice(player, $card);\n  })\n  .then(function (nextOrSamePlayer) {\n    var numCards = game.board.numCards;\n\n    game.hud.render(numCards, nextOrSamePlayer);\n    turnTaken.resolve(nextOrSamePlayer);\n  })\n  .fail(function (err) { throw err; });\n\n  return turnTaken.promise;\n};\n\nConcentration.prototype.endCondition = function () {\n  // Game never ends for now\n  return false;\n};\n\nConcentration.prototype.notice = function (msg) {\n  console.log(msg);\n};\n\n","function Deck () {\n  this.cards = [];\n  this.loadCards();\n}\n\nDeck.prototype.loadCards = function () {\n  var cards = this.cards;\n\n  for (var suit in Card.SUIT_SYMBOLS) {\n    for (var number in Card.NUMBER_SYMBOLS) {\n      var thisCard = new Card(suit, number);\n\n      cards.push(thisCard);\n    }\n  }\n};\n\nDeck.prototype.count = function () {\n  return this.cards.length;\n};\n\nDeck.prototype.shuffle = function () {\n /*\n  * As seen on stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n  */\n  var currentIndex = this.cards.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = this.cards[currentIndex];\n    this.cards[currentIndex] = this.cards[randomIndex];\n    this.cards[randomIndex] = temporaryValue;\n  }\n\n  return this;\n};\n\n","function Graveyard ($el) {\n  this.$el = $el;\n}\n\nGraveyard.prototype.add = function (cardTags) {\n  var $graveyard = this.$el;\n\n  cardTags.forEach(function (cardTag) {\n    var tagClone = cardTag.clone();\n    $graveyard.append(tagClone);\n  });\n};\n\n","function Hud ($el, player1, player2) {\n  this.$el = $el;\n  this.player1 = player1;\n  this.player2 = player2;\n}\n\nHud.prototype.render = function (numCards, currentPlayer) {\n  var $remainingCardsSpan = this.remainingCardsSpan(numCards),\n      $player1span = this.playerSpan(this.player1),\n      $player2span = this.playerSpan(this.player2);\n\n  if (currentPlayer) {\n    var $currentPlayerSpan = (currentPlayer == this.player1 ? $player1span : $player2span);\n    $currentPlayerSpan.addClass('active');\n  }\n\n  this.$el.html($remainingCardsSpan)\n          .append($player1span)\n          .append($player2span);\n};\n\nHud.prototype.playerSpan = function (player) {\n  var $span = $('<span>'),\n      content = \"Player \" + player.id + \" Matches: \"  + player.numMatches;\n\n  $span.addClass(\"player\" + player.id)\n       .html(content);\n\n  return $span;\n};\n\nHud.prototype.remainingCardsSpan = function (numCards) {\n  return $('<span>').append('Cards remaining: ' + numCards);\n};\n\n","// Inherits from Player class\nfunction HumanPlayer(args) {\n  Player.apply(this, arguments);\n}\n\nHumanPlayer.prototype = Object.create(Player.prototype);\nHumanPlayer.prototype.constructor = Player;\n\nHumanPlayer.prototype.getInput = function () {\n  var clicked = Q.defer();\n  this.board.on('click', function (evnt) {\n    var $card = $(evnt.target);\n\n    // Ignore click if player didn't click a card\n    // Or clicked a revealed card\n    if (!$card.hasClass('card') || !$card.hasClass('hidden')) return;\n\n    this.board.off('click');\n    clicked.resolve($card);\n  }.bind(this));\n\n  return clicked.promise;\n};\n\nHumanPlayer.prototype.confirmNextTurn = function () {\n  var $window = $(window), clicked = Q.defer();\n\n  $window.on('click', function () {\n    clicked.resolve();\n    $window.off('click');\n  });\n\n  return clicked.promise;\n};\n\n","function Inspector (board) {\n  this.board = board;\n  this.flippedCards = [];\n}\n\nInspector.prototype.evaluateChoice = function ($card) {\n  var outcome = \"continue\";\n\n  this.flippedCards.push($card);\n  this.inspect($card);\n  if (this.isShowingMax()) {\n    outcome = this.compareCards();\n  }\n\n  return outcome;\n};\n\nInspector.prototype.compareCards = function () {\n  if (_cardsHaveSameNumber(this.flippedCards)) {\n    // Flush out flipped cards by setting length to 0\n    return \"match\";\n  } else {\n    return \"miss\";\n  }\n\n  // Reduce cards to 'false' unless they all have the same number\n  function _cardsHaveSameNumber (cards) {\n    return !!cards.reduce(function (prevCard, card) {\n      if (prevCard.data && prevCard.data('number') == card.data('number')) {\n        return card;\n      }\n\n      return false;\n    });\n  }\n};\n\nInspector.prototype.inspect = function ($card) {\n  this.board.show($card);\n};\n\nInspector.prototype.isShowingMax = function () {\n  return this.flippedCards.length >= this.constructor.MAX_MATCHES;\n};\n\nInspector.prototype.removeMatches = function (player) {\n  this.board.remove(this.flippedCards, player);\n  this.flush();\n};\n\nInspector.prototype.hideCards = function () {\n  this.flippedCards.forEach(function($card) {\n    this.board.hide($card);\n  }.bind(this));\n\n  this.flush();\n};\n\nInspector.prototype.flush = function () {\n  this.flippedCards.length = 0;\n};\n\nInspector.MAX_MATCHES = 2;\n\n","$(function () {\n  new Concentration().play();\n});\n\n","// Superclass of ComputerPlayer and HumanPlayer\n\nfunction Player (id, board) {\n  this.id = id;\n  this.board = board;\n  this.numMatches = 0;\n}\n\nPlayer.prototype.takeTurn = function () {\n  var turnTaken = Q.defer();\n\n  this.getInput()\n  .then(function ($card) {\n    turnTaken.resolve($card);\n  })\n  .fail(function (err) {\n    throw err;\n  });\n\n  return turnTaken.promise;\n};\n\nPlayer.prototype.recordNewMatch = function () {\n  this.numMatches++;\n};\n\n","function Turn (board, player1, player2) {\n  this.board = board;\n  this.inspector = new Inspector(this.board);\n  this.player1 = player1;\n  this.player2 = player2;\n}\n\nTurn.prototype.handleChoice = function (player, $chosenCard) {\n  var choiceHandled = Q.defer(),\n      currentPlayer = (player == this.player1 ? this.player1 : this.player2),\n      nextPlayer = (player == this.player1 ? this.player2 : this.player1),\n\n      turnOutcome = this.inspector.evaluateChoice($chosenCard);\n\n  switch(turnOutcome) {\n    case \"continue\":\n      // Player keeps going if the max number of cards\n      // hasn't been flipped\n      choiceHandled.resolve(currentPlayer);\n      break;\n    case \"match\":\n      currentPlayer.confirmNextTurn()\n      .then(function () {\n        currentPlayer.recordNewMatch();\n        this.inspector.removeMatches(currentPlayer);\n        choiceHandled.resolve(currentPlayer);\n      }.bind(this))\n      .fail(function (err) { throw err; });\n      break;\n    case \"miss\":\n      currentPlayer.confirmNextTurn()\n      .then(function () {\n        this.inspector.hideCards();\n        choiceHandled.resolve(nextPlayer);\n      }.bind(this))\n      .fail(function (err) { throw err; });\n      break;\n    default:\n      throw new Error(\"Unknown choice outcome\");\n  }\n\n  return choiceHandled.promise;\n};\n\n","/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\nfunction LRUCache (limit) {\n  // Current size of the cache. (Read-only).\n  this.size = 0;\n  // Maximum number of items this cache can hold.\n  this.limit = limit;\n  this._keymap = {};\n}\n\n/**\n * Put <value> into the cache associated with <key>. Returns the entry which was\n * removed to make room for the new entry. Otherwise undefined is returned\n * (i.e. if there was enough room already).\n */\nLRUCache.prototype.put = function(key, value) {\n  var entry = {key:key, value:value};\n  // Note: No protection agains replacing, and thus orphan entries. By design.\n  this._keymap[key] = entry;\n  if (this.tail) {\n    // link previous tail to the new tail (entry)\n    this.tail.newer = entry;\n    entry.older = this.tail;\n  } else {\n    // we're first in -- yay\n    this.head = entry;\n  }\n  // add new entry to the end of the linked list -- it's now the freshest entry.\n  this.tail = entry;\n  if (this.size === this.limit) {\n    // we hit the limit -- remove the head\n    return this.shift();\n  } else {\n    // increase the size counter\n    this.size++;\n  }\n};\n\n/**\n * Purge the least recently used (oldest) entry from the cache. Returns the\n * removed entry or undefined if the cache was empty.\n *\n * If you need to perform any form of finalization of purged items, this is a\n * good place to do it. Simply override/replace this function:\n *\n *   var c = new LRUCache(123);\n *   c.shift = function() {\n *     var entry = LRUCache.prototype.shift.call(this);\n *     doSomethingWith(entry);\n *     return entry;\n *   }\n */\nLRUCache.prototype.shift = function() {\n  // todo: handle special case when limit == 1\n  var entry = this.head;\n  if (entry) {\n    if (this.head.newer) {\n      this.head = this.head.newer;\n      this.head.older = undefined;\n    } else {\n      this.head = undefined;\n    }\n    // Remove last strong reference to <entry> and remove links from the purged\n    // entry being returned:\n    entry.newer = entry.older = undefined;\n    // delete is slow, but we need to do this to avoid uncontrollable growth:\n    delete this._keymap[entry.key];\n  }\n  return entry;\n};\n\n/**\n * Get and register recent use of <key>. Returns the value associated with <key>\n * or undefined if not in cache.\n */\nLRUCache.prototype.get = function(key, returnEntry) {\n  // First, find our cache entry\n  var entry = this._keymap[key];\n  if (entry === undefined) return; // Not cached. Sorry.\n  // As <key> was found in the cache, register it as being requested recently\n  if (entry === this.tail) {\n    // Already the most recenlty used entry, so no need to update the list\n    return returnEntry ? entry : entry.value;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head)\n      this.head = entry.newer;\n    entry.newer.older = entry.older; // C <-- E.\n  }\n  if (entry.older)\n    entry.older.newer = entry.newer; // C. --> E\n  entry.newer = undefined; // D --x\n  entry.older = this.tail; // D. --> E\n  if (this.tail)\n    this.tail.newer = entry; // E. <-- D\n  this.tail = entry;\n  return returnEntry ? entry : entry.value;\n};\n\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n\n/**\n * Check if <key> is in the cache without registering recent use. Feasible if\n * you do not want to chage the state of the cache, but only \"peek\" at it.\n * Returns the entry associated with <key> if found, or undefined if not found.\n */\nLRUCache.prototype.find = function(key) {\n  return this._keymap[key];\n};\n\n/**\n * Update the value of entry with <key>. Returns the old value, or undefined if\n * entry was not in the cache.\n */\nLRUCache.prototype.set = function(key, value) {\n  var oldvalue, entry = this.get(key, true);\n  if (entry) {\n    oldvalue = entry.value;\n    entry.value = value;\n  } else {\n    oldvalue = this.put(key, value);\n    if (oldvalue) oldvalue = oldvalue.value;\n  }\n  return oldvalue;\n};\n\n/**\n * Remove entry <key> from cache and return its value. Returns undefined if not\n * found.\n */\nLRUCache.prototype.remove = function(key) {\n  var entry = this._keymap[key];\n  if (!entry) return;\n  delete this._keymap[entry.key]; // need to do delete unfortunately\n  if (entry.newer && entry.older) {\n    // relink the older entry with the newer entry\n    entry.older.newer = entry.newer;\n    entry.newer.older = entry.older;\n  } else if (entry.newer) {\n    // remove the link to us\n    entry.newer.older = undefined;\n    // link the newer entry to head\n    this.head = entry.newer;\n  } else if (entry.older) {\n    // remove the link to us\n    entry.older.newer = undefined;\n    // link the newer entry to head\n    this.tail = entry.older;\n  } else {// if(entry.older === undefined && entry.newer === undefined) {\n    this.head = this.tail = undefined;\n  }\n\n  this.size--;\n  return entry.value;\n};\n\n/** Removes all entries */\nLRUCache.prototype.removeAll = function() {\n  // This should be safe, as we never expose strong refrences to the outside\n  this.head = this.tail = undefined;\n  this.size = 0;\n  this._keymap = {};\n};\n\n/**\n * Return an array containing all keys of entries stored in the cache object, in\n * arbitrary order.\n */\nif (typeof Object.keys === 'function') {\n  LRUCache.prototype.keys = function() { return Object.keys(this._keymap); };\n} else {\n  LRUCache.prototype.keys = function() {\n    var keys = [];\n    for (var k in this._keymap) keys.push(k);\n    return keys;\n  };\n}\n\n/**\n * Call `fun` for each entry. Starting with the newest entry if `desc` is a true\n * value, otherwise starts with the oldest (head) enrty and moves towards the\n * tail.\n *\n * `fun` is called with 3 arguments in the context `context`:\n *   `fun.call(context, Object key, Object value, LRUCache self)`\n */\nLRUCache.prototype.forEach = function(fun, context, desc) {\n  var entry;\n  if (context === true) { desc = true; context = undefined; }\n  else if (typeof context !== 'object') context = this;\n  if (desc) {\n    entry = this.tail;\n    while (entry) {\n      fun.call(context, entry.key, entry.value, this);\n      entry = entry.older;\n    }\n  } else {\n    entry = this.head;\n    while (entry) {\n      fun.call(context, entry.key, entry.value, this);\n      entry = entry.newer;\n    }\n  }\n};\n\n/** Returns a JSON (array) representation */\nLRUCache.prototype.toJSON = function() {\n  var s = [], entry = this.head;\n  while (entry) {\n    s.push({key:entry.key.toJSON(), value:entry.value.toJSON()});\n    entry = entry.newer;\n  }\n  return s;\n};\n\n/** Returns a String representation */\nLRUCache.prototype.toString = function() {\n  var s = '', entry = this.head;\n  while (entry) {\n    s += String(entry.key)+':'+entry.value;\n    entry = entry.newer;\n    if (entry)\n      s += ' < ';\n  }\n  return s;\n};\n\n// Export ourselves\nif (typeof this === 'object') this.LRUCache = LRUCache;"],"sourceRoot":"/source/"}